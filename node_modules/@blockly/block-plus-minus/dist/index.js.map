{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/block-plus-minus/webpack/universalModuleDefinition","webpack://@blockly/block-plus-minus/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/block-plus-minus/webpack/bootstrap","webpack://@blockly/block-plus-minus/webpack/runtime/compat get default export","webpack://@blockly/block-plus-minus/webpack/runtime/define property getters","webpack://@blockly/block-plus-minus/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/block-plus-minus/webpack/runtime/make namespace object","webpack://@blockly/block-plus-minus/./src/serialization_helper.js","webpack://@blockly/block-plus-minus/./src/field_minus.js","webpack://@blockly/block-plus-minus/./src/field_plus.js","webpack://@blockly/block-plus-minus/./src/if.js","webpack://@blockly/block-plus-minus/./src/list_create.js","webpack://@blockly/block-plus-minus/./src/procedures.js","webpack://@blockly/block-plus-minus/./src/text_join.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Returns the extra state of the given block (either as XML or a JSO, depending\n * on the block's definition).\n * @param {!Blockly.BlockSvg} block The block to get the extra state of.\n * @returns {string} A stringified version of the extra state of the given\n *     block.\n */\nexport function getExtraBlockState(block) {\n  // TODO: This is a dupe of the BlockChange.getExtraBlockState code, do we\n  //    want to make that public?\n  if (block.saveExtraState) {\n    const state = block.saveExtraState();\n    return state ? JSON.stringify(state) : '';\n  } else if (block.mutationToDom) {\n    const state = block.mutationToDom();\n    return state ? Blockly.Xml.domToText(state) : '';\n  }\n  return '';\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A function that creates a minus button used for mutation.\n */\n'use strict';\n\nimport * as Blockly from 'blockly/core';\nimport {getExtraBlockState} from './serialization_helper';\n\n/**\n * Creates a minus image field used for mutation.\n * @param {Object=} args Untyped args passed to block.minus when the field\n *     is clicked.\n * @returns {Blockly.FieldImage} The minus field.\n */\nexport function createMinusField(args = undefined) {\n  const minus = new Blockly.FieldImage(minusImage, 15, 15, undefined, onClick_);\n  /**\n   * Untyped args passed to block.minus when the field is clicked.\n   * @type {?(Object|undefined)}\n   * @private\n   */\n  minus.args_ = args;\n  return minus;\n}\n\n/**\n * Calls block.minus(args) when the minus field is clicked.\n * @param {Blockly.FieldImage} minusField The field being clicked.\n * @private\n */\nfunction onClick_(minusField) {\n  // TODO: This is a dupe of the mutator code, anyway to unify?\n  const block = minusField.getSourceBlock();\n\n  if (block.isInFlyout) {\n    return;\n  }\n\n  Blockly.Events.setGroup(true);\n  const oldExtraState = getExtraBlockState(block);\n  block.minus(minusField.args_);\n  const newExtraState = getExtraBlockState(block);\n\n  if (oldExtraState != newExtraState) {\n    Blockly.Events.fire(new Blockly.Events.BlockChange(\n        block, 'mutation', null, oldExtraState, newExtraState));\n  }\n  Blockly.Events.setGroup(false);\n}\n\nconst minusImage =\n    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAw' +\n    'MC9zdmciIHZlcnNpb249IjEuMSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48cGF0aCBkPS' +\n    'JNMTggMTFoLTEyYy0xLjEwNCAwLTIgLjg5Ni0yIDJzLjg5NiAyIDIgMmgxMmMxLjEwNCAw' +\n    'IDItLjg5NiAyLTJzLS44OTYtMi0yLTJ6IiBmaWxsPSJ3aGl0ZSIgLz48L3N2Zz4K';\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A field for a plus button used for mutation.\n */\n'use strict';\n\nimport * as Blockly from 'blockly/core';\nimport {getExtraBlockState} from './serialization_helper';\n\n/**\n * Creates a plus image field used for mutation.\n * @param {Object=} args Untyped args passed to block.minus when the field\n *     is clicked.\n * @returns {Blockly.FieldImage} The Plus field.\n */\nexport function createPlusField(args = undefined) {\n  const plus = new Blockly.FieldImage(plusImage, 15, 15, undefined, onClick_);\n  /**\n   * Untyped args passed to block.plus when the field is clicked.\n   * @type {?(Object|undefined)}\n   * @private\n   */\n  plus.args_ = args;\n  return plus;\n}\n\n/**\n * Calls block.plus(args) when the plus field is clicked.\n * @param {!Blockly.FieldImage} plusField The field being clicked.\n * @private\n */\nfunction onClick_(plusField) {\n  // TODO: This is a dupe of the mutator code, anyway to unify?\n  const block = plusField.getSourceBlock();\n\n  if (block.isInFlyout) {\n    return;\n  }\n\n  Blockly.Events.setGroup(true);\n  const oldExtraState = getExtraBlockState(block);\n  block.plus(plusField.args_);\n  const newExtraState = getExtraBlockState(block);\n\n  if (oldExtraState != newExtraState) {\n    Blockly.Events.fire(new Blockly.Events.BlockChange(\n        block, 'mutation', null, oldExtraState, newExtraState));\n  }\n  Blockly.Events.setGroup(false);\n}\n\nconst plusImage =\n    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC' +\n    '9zdmciIHZlcnNpb249IjEuMSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48cGF0aCBkPSJNMT' +\n    'ggMTBoLTR2LTRjMC0xLjEwNC0uODk2LTItMi0ycy0yIC44OTYtMiAybC4wNzEgNGgtNC4wNz' +\n    'FjLTEuMTA0IDAtMiAuODk2LTIgMnMuODk2IDIgMiAybDQuMDcxLS4wNzEtLjA3MSA0LjA3MW' +\n    'MwIDEuMTA0Ljg5NiAyIDIgMnMyLS44OTYgMi0ydi00LjA3MWw0IC4wNzFjMS4xMDQgMCAyLS' +\n    '44OTYgMi0ycy0uODk2LTItMi0yeiIgZmlsbD0id2hpdGUiIC8+PC9zdmc+Cg==';\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the if block to use a +/- mutator UI.\n */\n\nimport Blockly from 'blockly/core';\nimport {createMinusField} from './field_minus';\nimport {createPlusField} from './field_plus';\n\nconst controlsIfMutator = {\n  /**\n   * Number of else-if inputs on this block.\n   * @type {number}\n   */\n  elseIfCount_: 0,\n  /**\n   * Whether this block has an else input or not.\n   * @type {boolean}\n   */\n  hasElse_: false,\n\n  /**\n   * Creates XML to represent the number of else-if and else inputs.\n   * @returns {Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function() {\n    if (!this.elseIfCount_ && !this.hasElse_) {\n      return null;\n    }\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('elseif', this.elseIfCount_);\n    if (this.hasElse_) {\n      // Has to be stored as an int for backwards compat.\n      container.setAttribute('else', 1);\n    }\n    return container;\n  },\n\n  /**\n   * Parses XML to restore the else-if and else inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    const targetCount = parseInt(xmlElement.getAttribute('elseif'), 10) || 0;\n    this.hasElse_ = !!parseInt(xmlElement.getAttribute('else'), 10) || 0;\n    if (this.hasElse_ && !this.getInput('ELSE')) {\n      this.appendStatementInput('ELSE')\n          .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSE']);\n    }\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @returns {{elseIfCount: (number|undefined),\n   *     haseElse: (boolean|undefined)}} The state of this block, ie the else\n   *     if count and else state.\n   */\n  saveExtraState: function() {\n    if (!this.elseIfCount_ && !this.hasElse_) {\n      return null;\n    }\n    const state = Object.create(null);\n    if (this.elseIfCount_) {\n      state['elseIfCount'] = this.elseIfCount_;\n    }\n    if (this.hasElse_) {\n      state['hasElse'] = true;\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, ie the else if count and\n   *     else state.\n   */\n  loadExtraState: function(state) {\n    const targetCount = state['elseIfCount'] || 0;\n    this.hasElse_ = state['hasElse'] || false;\n    if (this.hasElse_ && !this.getInput('ELSE')) {\n      this.appendStatementInput('ELSE')\n          .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSE']);\n    }\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Adds else-if and do inputs to the block until the block matches the\n   * target else-if count.\n   * @param {number} targetCount The target number of else-if inputs.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function(targetCount) {\n    while (this.elseIfCount_ < targetCount) {\n      this.addElseIf_();\n    }\n    while (this.elseIfCount_ > targetCount) {\n      this.removeElseIf_();\n    }\n  },\n\n  /**\n   * Callback for the plus field. Adds an else-if input to the block.\n   */\n  plus: function() {\n    this.addElseIf_();\n  },\n\n  /**\n   * Callback for the minus field. Triggers \"removing\" the input at the specific\n   * index.\n   * @see removeInput_\n   * @param {number} index The index of the else-if input to \"remove\".\n   * @this {Blockly.Block}\n   */\n  minus: function(index) {\n    if (this.elseIfCount_ == 0) {\n      return;\n    }\n    this.removeElseIf_(index);\n  },\n\n  /**\n   * Adds an else-if and a do input to the bottom of the block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  addElseIf_: function() {\n    // Because else-if inputs are 1-indexed we increment first, decrement last.\n    this.elseIfCount_++;\n    this.appendValueInput('IF' + this.elseIfCount_)\n        .setCheck('Boolean')\n        .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSEIF'])\n        .appendField(\n            createMinusField(this.elseIfCount_), 'MINUS' + this.elseIfCount_);\n    this.appendStatementInput('DO' + this.elseIfCount_)\n        .appendField(Blockly.Msg['CONTROLS_IF_MSG_THEN']);\n\n    // Handle if-elseif-else block.\n    if (this.getInput('ELSE')) {\n      this.moveInputBefore('ELSE', /* put at end */ null);\n    }\n  },\n\n  /**\n   * Appears to remove the input at the given index. Actually shifts attached\n   * blocks and then removes the input at the bottom of the block. This is to\n   * make sure the inputs are always IF0, IF1, etc with no gaps.\n   * @param {?number=} index The index of the input to \"remove\", or undefined\n   *     to remove the last input.\n   * @this {Blockly.Block}\n   * @private\n   */\n  removeElseIf_: function(index = undefined) {\n    // The strategy for removing a part at an index is to:\n    //  - Kick any blocks connected to the relevant inputs.\n    //  - Move all connect blocks from the other inputs up.\n    //  - Remove the last input.\n    // This makes sure all of our indices are correct.\n\n    if (index !== undefined && index!= this.elseIfCount_) {\n      // Each else-if is two inputs on the block:\n      // the else-if input and the do input.\n      const elseIfIndex = index * 2;\n      const inputs = this.inputList;\n      let connection = inputs[elseIfIndex].connection; // If connection.\n      if (connection.isConnected()) {\n        connection.disconnect();\n      }\n      connection = inputs[elseIfIndex + 1].connection; // Do connection.\n      if (connection.isConnected()) {\n        connection.disconnect();\n      }\n      this.bumpNeighbours();\n      for (let i = elseIfIndex + 2, input; (input = this.inputList[i]); i++) {\n        if (input.name == 'ELSE') {\n          break; // Should be last, so break.\n        }\n        const targetConnection = input.connection.targetConnection;\n        if (targetConnection) {\n          this.inputList[i - 2].connection.connect(targetConnection);\n        }\n      }\n    }\n\n    this.removeInput('IF' + this.elseIfCount_);\n    this.removeInput('DO' + this.elseIfCount_);\n    // Because else-if inputs are 1-indexed we increment first, decrement last.\n    this.elseIfCount_--;\n  },\n};\n\n/**\n * Adds the initial plus button to the if block.\n * @this {Blockly.Block}\n */\nconst controlsIfHelper = function() {\n  this.getInput('IF0').insertFieldAt(0, createPlusField(), 'PLUS');\n};\n\nif (Blockly.Extensions.isRegistered('controls_if_mutator')) {\n  Blockly.Extensions.unregister('controls_if_mutator');\n}\nBlockly.Extensions.registerMutator('controls_if_mutator',\n    controlsIfMutator, controlsIfHelper);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the list_create block to use a +/- mutator UI.\n */\n\nimport Blockly from 'blockly/core';\nimport {createPlusField} from './field_plus';\nimport {createMinusField} from './field_minus';\n\n// Delete original block because there's no way to unregister it:\n// https://github.com/google/blockly-samples/issues/768#issuecomment-885663394\ndelete Blockly.Blocks['lists_create_with'];\n\n/* eslint-disable quotes */\nBlockly.defineBlocksWithJsonArray([\n  {\n    \"type\": \"lists_create_with\",\n    \"message0\": \"%{BKY_LISTS_CREATE_EMPTY_TITLE} %1\",\n    \"args0\": [\n      {\n        \"type\": \"input_dummy\",\n        \"name\": \"EMPTY\",\n      },\n    ],\n    \"output\": \"Array\",\n    \"style\": \"list_blocks\",\n    \"helpUrl\": \"%{BKY_LISTS_CREATE_WITH_HELPURL}\",\n    \"tooltip\": \"%{BKY_LISTS_CREATE_WITH_TOOLTIP}\",\n    \"mutator\": \"new_list_create_with_mutator\",\n  },\n]);\n/* eslint-enable quotes */\n\nconst listCreateMutator = {\n  /**\n   * Number of item inputs the block has.\n   * @type {number}\n   */\n  itemCount_: 0,\n\n  /**\n   * Creates XML to represent number of text inputs.\n   * @returns {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function() {\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('items', this.itemCount_);\n    return container;\n  },\n  /**\n   * Parses XML to restore the text inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    const targetCount = parseInt(xmlElement.getAttribute('items'), 10);\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @returns {{itemCount: number}} The state of this block, ie the item count.\n   */\n  saveExtraState: function() {\n    return {\n      'itemCount': this.itemCount_,\n    };\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, ie the item count.\n   */\n  loadExtraState: function(state) {\n    this.updateShape_(state['itemCount']);\n  },\n\n  /**\n   * Adds inputs to the block until it reaches the target number of inputs.\n   * @param {number} targetCount The target number of inputs for the block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function(targetCount) {\n    while (this.itemCount_ < targetCount) {\n      this.addPart_();\n    }\n    while (this.itemCount_ > targetCount) {\n      this.removePart_();\n    }\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the plus image. Adds an input to the end of the block and\n   * updates the state of the minus.\n   */\n  plus: function() {\n    this.addPart_();\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the minus image. Removes an input from the end of the block\n   * and updates the state of the minus.\n   */\n  minus: function() {\n    if (this.itemCount_ == 0) {\n      return;\n    }\n    this.removePart_();\n    this.updateMinus_();\n  },\n\n  // To properly keep track of indices we have to increment before/after adding\n  // the inputs, and decrement the opposite.\n  // Because we want our first input to be ADD0 (not ADD1) we increment after.\n\n  /**\n   * Adds an input to the end of the block. If the block currently has no\n   * inputs it updates the top 'EMPTY' input to receive a block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  addPart_: function() {\n    if (this.itemCount_ == 0) {\n      this.removeInput('EMPTY');\n      this.topInput_ = this.appendValueInput('ADD' + this.itemCount_)\n          .appendField(createPlusField(), 'PLUS')\n          .appendField(Blockly.Msg['LISTS_CREATE_WITH_INPUT_WITH']);\n    } else {\n      this.appendValueInput('ADD' + this.itemCount_);\n    }\n    this.itemCount_++;\n  },\n\n  /**\n   * Removes an input from the end of the block. If we are removing the last\n   * input this updates the block to have an 'EMPTY' top input.\n   * @this {Blockly.Block}\n   * @private\n   */\n  removePart_: function() {\n    this.itemCount_--;\n    this.removeInput('ADD' + this.itemCount_);\n    if (this.itemCount_ == 0) {\n      this.topInput_ = this.appendDummyInput('EMPTY')\n          .appendField(createPlusField(), 'PLUS')\n          .appendField(Blockly.Msg['LISTS_CREATE_EMPTY_TITLE']);\n    }\n  },\n\n  /**\n   * Makes it so the minus is visible iff there is an input available to remove.\n   * @private\n   */\n  updateMinus_: function() {\n    const minusField = this.getField('MINUS');\n    if (!minusField && this.itemCount_ > 0) {\n      this.topInput_.insertFieldAt(1, createMinusField(), 'MINUS');\n    } else if (minusField && this.itemCount_ < 1) {\n      this.topInput_.removeField('MINUS');\n    }\n  },\n};\n\n/**\n * Updates the shape of the block to have 3 inputs if no mutation is provided.\n * @this {Blockly.Block}\n */\nconst listCreateHelper = function() {\n  this.getInput('EMPTY').insertFieldAt(0, createPlusField(), 'PLUS');\n  this.updateShape_(3);\n};\n\nBlockly.Extensions.registerMutator('new_list_create_with_mutator',\n    listCreateMutator, listCreateHelper);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the procedure blocks to use a +/- mutator UI.\n */\n\nimport Blockly from 'blockly/core';\nimport {createMinusField} from './field_minus';\nimport {createPlusField} from './field_plus';\n\nBlockly.Msg['PROCEDURE_VARIABLE'] = 'variable:';\n\n// Delete original blocks because there's no way to unregister them:\n// https://github.com/google/blockly-samples/issues/768#issuecomment-885663394\ndelete Blockly.Blocks['procedures_defnoreturn'];\ndelete Blockly.Blocks['procedures_defreturn'];\n\n/* eslint-disable quotes */\nBlockly.defineBlocksWithJsonArray([\n  {\n    \"type\": \"procedures_defnoreturn\",\n    \"message0\": \"%{BKY_PROCEDURES_DEFNORETURN_TITLE} %1 %2\",\n    \"message1\": \"%{BKY_PROCEDURES_DEFNORETURN_DO} %1\",\n    \"args0\": [\n      {\n        \"type\": \"field_input\",\n        \"name\": \"NAME\",\n        \"text\": \"\",\n      },\n      {\n        \"type\": \"input_dummy\",\n        \"name\": \"TOP\",\n      },\n    ],\n    \"args1\": [\n      {\n        \"type\": \"input_statement\",\n        \"name\": \"STACK\",\n      },\n    ],\n    \"style\": \"procedure_blocks\",\n    \"helpUrl\": \"%{BKY_PROCEDURES_DEFNORETURN_HELPURL}\",\n    \"tooltip\": \"%{BKY_PROCEDURES_DEFNORETURN_TOOLTIP}\",\n    \"extensions\": [\n      \"get_procedure_def_no_return\",\n      \"procedure_context_menu\",\n      \"procedure_rename\",\n      \"procedure_vars\",\n    ],\n    \"mutator\": \"procedure_def_mutator\",\n  },\n  {\n    \"type\": \"procedures_defreturn\",\n    \"message0\": \"%{BKY_PROCEDURES_DEFRETURN_TITLE} %1 %2\",\n    \"message1\": \"%{BKY_PROCEDURES_DEFRETURN_DO} %1\",\n    \"message2\": \"%{BKY_PROCEDURES_DEFRETURN_RETURN} %1\",\n    \"args0\": [\n      {\n        \"type\": \"field_input\",\n        \"name\": \"NAME\",\n        \"text\": \"\",\n      },\n      {\n        \"type\": \"input_dummy\",\n        \"name\": \"TOP\",\n      },\n    ],\n    \"args1\": [\n      {\n        \"type\": \"input_statement\",\n        \"name\": \"STACK\",\n      },\n    ],\n    \"args2\": [\n      {\n        \"type\": \"input_value\",\n        \"align\": \"right\",\n        \"name\": \"RETURN\",\n      },\n    ],\n    \"style\": \"procedure_blocks\",\n    \"helpUrl\": \"%{BKY_PROCEDURES_DEFRETURN_HELPURL}\",\n    \"tooltip\": \"%{BKY_PROCEDURES_DEFRETURN_TOOLTIP}\",\n    \"extensions\": [\n      \"get_procedure_def_return\",\n      \"procedure_context_menu\",\n      \"procedure_rename\",\n      \"procedure_vars\",\n    ],\n    \"mutator\": \"procedure_def_mutator\",\n  },\n]);\n/* eslint-enable quotes */\n\n/**\n * Defines the what are essentially info-getters for the procedures_defnoreturn\n * block.\n * @type {{callType_: string, getProcedureDef: (function(): Array)}}\n */\nconst getDefNoReturn = {\n  /**\n   * Returns info about this block to be used by the Blockly.Procedures.\n   * @returns {Array} An array of info.\n   * @this {Blockly.Block}\n   */\n  getProcedureDef: function() {\n    const argNames = this.argData_.map((elem) => elem.model.name);\n    return [this.getFieldValue('NAME'), argNames, false];\n  },\n\n  /**\n   * Used by the context menu to create a caller block.\n   * @type {string}\n   */\n  callType_: 'procedures_callnoreturn',\n};\n\nBlockly.Extensions.registerMixin('get_procedure_def_no_return', getDefNoReturn);\n\n/**\n * Defines what are essentially info-getters for the procedures_def_return\n * block.\n * @type {{callType_: string, getProcedureDef: (function(): Array)}}\n */\nconst getDefReturn = {\n  /**\n   * Returns info about this block to be used by the Blockly.Procedures.\n   * @returns {Array} An array of info.\n   * @this {Blockly.Block}\n   */\n  getProcedureDef: function() {\n    const argNames = this.argData_.map((elem) => elem.model.name);\n    return [this.getFieldValue('NAME'), argNames, true];\n  },\n  /**\n   * Used by the context menu to create a caller block.\n   * @type {string}\n   */\n  callType_: 'procedures_callreturn',\n};\n\nBlockly.Extensions.registerMixin('get_procedure_def_return', getDefReturn);\n\nconst procedureContextMenu = {\n  /**\n   * Adds an option to create a caller block.\n   * Adds an option to create a variable getter for each variable included in\n   * the procedure definition.\n   * @this {Blockly.Block}\n   * @param {!Array} options The current options for the context menu.\n   */\n  customContextMenu: function(options) {\n    if (this.isInFlyout) {\n      return;\n    }\n\n    // Add option to create caller.\n    const name = this.getFieldValue('NAME');\n    const text = Blockly.Msg['PROCEDURES_CREATE_DO'].replace('%1', name);\n\n    const xml = Blockly.utils.xml.createElement('block');\n    xml.setAttribute('type', this.callType_);\n    xml.appendChild(this.mutationToDom(true));\n    const callback = Blockly.ContextMenu.callbackFactory(this, xml);\n\n    options.push({\n      enabled: true,\n      text: text,\n      callback: callback,\n    });\n\n    if (this.isCollapsed()) {\n      return;\n    }\n\n    // Add options to create getters for each parameter.\n    const varModels = this.getVarModels();\n    for (const model of varModels) {\n      const text = Blockly.Msg['VARIABLES_SET_CREATE_GET']\n          .replace('%1', model.name);\n\n      const xml = Blockly.utils.xml.createElement('block');\n      xml.setAttribute('type', 'variables_get');\n      xml.appendChild(Blockly.Variables.generateVariableFieldDom(model));\n      const callback = Blockly.ContextMenu.callbackFactory(this, xml);\n\n      options.push({\n        enabled: true,\n        text: text,\n        callback: callback,\n      });\n    }\n  },\n};\n\nBlockly.Extensions.registerMixin(\n    'procedure_context_menu', procedureContextMenu);\n\nconst procedureDefMutator = {\n  /**\n   * Create XML to represent the argument inputs.\n   * @param {boolean=} isForCaller If true include the procedure name and\n   *     argument IDs. Used by Blockly.Procedures.mutateCallers for\n   *     reconnection.\n   * @returns {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function(isForCaller = false) {\n    const container = Blockly.utils.xml.createElement('mutation');\n    if (isForCaller) {\n      container.setAttribute('name', this.getFieldValue('NAME'));\n    }\n    this.argData_.forEach((element) => {\n      const argument = Blockly.utils.xml.createElement('arg');\n      const argModel = element.model;\n      argument.setAttribute('name', argModel.name);\n      argument.setAttribute('varid', argModel.getId());\n      argument.setAttribute('argid', element.argId);\n      if (isForCaller) {\n        argument.setAttribute('paramid', element.argId);\n      }\n      container.appendChild(argument);\n    });\n\n    // Not used by this block, but necessary if switching back and forth\n    // between this mutator UI and the default UI.\n    if (!this.hasStatements_) {\n      container.setAttribute('statements', 'false');\n    }\n\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the argument inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    // We have to handle this so that the user doesn't add blocks to the stack,\n    // in which case it would be impossible to return to the old mutators.\n    this.hasStatements_ = xmlElement.getAttribute('statements') !== 'false';\n    if (!this.hasStatements_) {\n      this.removeInput('STACK');\n    }\n\n    const names = [];\n    const varIds = [];\n    const argIds = [];\n    for (const childNode of xmlElement.childNodes) {\n      if (childNode.nodeName.toLowerCase() == 'arg') {\n        names.push(childNode.getAttribute('name'));\n        varIds.push(childNode.getAttribute('varid') ||\n            childNode.getAttribute('varId'));\n        argIds.push(childNode.getAttribute('argid'));\n      }\n    }\n    this.updateShape_(names, varIds, argIds);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @returns {{params: (!Array<{name: string, id: string}>|undefined),\n   *     hasStatements: (boolean|undefined)}} The state of this block, eg the\n   *     parameters and statements.\n   */\n  saveExtraState: function() {\n    if (!this.argData_.length && this.hasStatements_) {\n      return null;\n    }\n\n    const state = Object.create(null);\n    if (this.argData_.length) {\n      state['params'] = [];\n      this.argData_.forEach((arg) => {\n        const model = arg.model;\n        state['params'].push({\n          'name': model.name,\n          'id': model.getId(),\n          'argId': arg.argId,\n        });\n      });\n    }\n    if (!this.hasStatements_) {\n      state['hasStatements'] = false;\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, eg the parameters and\n   *     statements.\n   */\n  loadExtraState: function(state) {\n    // We have to handle this so that the user doesn't add blocks to the stack,\n    // in which case it would be impossible to return to the old mutators.\n    this.hasStatements_ = state['hasStatements'] !== false;\n    if (!this.hasStatements_) {\n      this.removeInput('STACK');\n    }\n\n    const names = [];\n    const varIds = [];\n    const argIds = [];\n    if (state['params']) {\n      for (let i = 0; i < state['params'].length; i++) {\n        const param = state['params'][i];\n        names.push(param['name']);\n        varIds.push(param['id']);\n        argIds.push(param['argId']);\n      }\n    }\n    this.updateShape_(names, varIds, argIds);\n  },\n\n  /**\n   * Adds arguments to the block until it matches the targets.\n   * @param {!Array<string>} names An array of argument names to display.\n   * @param {!Array<string>} varIds An array of variable IDs associated with\n   *     those names.\n   * @param {!Array<?string>} argIds An array of argument IDs associated with\n   *     those names.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function(names, varIds, argIds) {\n    if (names.length != varIds.length) {\n      throw Error('names and varIds must have the same length.');\n    }\n    // Usually it's more efficient to modify the block, rather than tearing it\n    // down and rebuilding (less render calls), but in this case it's easier\n    // to just work from scratch.\n\n    // We need to remove args in reverse order so that it doesn't mess up\n    // as removeArg_ modifies our array.\n    for (let i = this.argData_.length - 1; i >= 0; i--) {\n      this.removeArg_(this.argData_[i].argId);\n    }\n    this.argData_ = [];\n    const length = varIds.length;\n    for (let i = 0; i < length; i++) {\n      this.addArg_(names[i], varIds[i], argIds[i]);\n    }\n    Blockly.Procedures.mutateCallers(this);\n  },\n\n  /**\n   * Callback for the plus image. Adds an argument to the block and mutates\n   * callers to match.\n   */\n  plus: function() {\n    this.addArg_();\n    Blockly.Procedures.mutateCallers(this);\n  },\n\n  /**\n   * Callback for the minus image. Removes the argument associated with the\n   * given argument ID and mutates the callers to match.\n   * @param {string} argId The argId of the argument to remove.\n   * @this {Blockly.Block}\n   */\n  minus: function(argId) {\n    if (!this.argData_.length) {\n      return;\n    }\n    this.removeArg_(argId);\n    Blockly.Procedures.mutateCallers(this);\n  },\n\n  /**\n   * Adds an argument to the block and updates the block's parallel tracking\n   * arrays as appropriate.\n   * @param {?string=} name An optional name for the argument.\n   * @param {?string=} varId An optional variable ID for the argument.\n   * @param {?string=} argId An optional argument ID for the argument\n   *     (used to identify the argument across variable merges).\n   * @this {Blockly.Block}\n   * @private\n   */\n  addArg_: function(name = null, varId = null, argId = null) {\n    if (!this.argData_.length) {\n      const withField = new Blockly.FieldLabel(\n          Blockly.Msg['PROCEDURES_BEFORE_PARAMS']);\n      this.getInput('TOP')\n          .appendField(withField, 'WITH');\n    }\n\n    const argNames = this.argData_.map((elem) => elem.model.name);\n    name = name || Blockly.Variables.generateUniqueNameFromOptions(\n        Blockly.Procedures.DEFAULT_ARG, argNames);\n    const variable = Blockly.Variables.getOrCreateVariablePackage(\n        this.workspace, varId, name, '');\n    argId = argId || Blockly.utils.idGenerator.genUid();\n\n    this.addVarInput_(name, argId);\n    if (this.getInput('STACK')) {\n      this.moveInputBefore(argId, 'STACK');\n    } else {\n      this.moveInputBefore(argId, 'RETURN');\n    }\n\n    this.argData_.push({\n      model: variable,\n      argId: argId,\n    });\n  },\n\n  /**\n   * Removes the argument associated with the given argument ID from the block.\n   * @param {string} argId An ID used to track arguments on the block.\n   * @private\n   */\n  removeArg_: function(argId) {\n    if (this.removeInput(argId, true)) {\n      if (this.argData_.length == 1) { // Becoming argumentless.\n        this.getInput('TOP').removeField('WITH');\n      }\n      this.argData_ = this.argData_.filter((element) => element.argId != argId);\n    }\n  },\n\n  /**\n   * Appends the actual inputs and fields associated with an argument to the\n   * block.\n   * @param {string} name The name of the argument.\n   * @param {string} argId The UUID of the argument (different from var ID).\n   * @this {Blockly.Block}\n   * @private\n   */\n  addVarInput_: function(name, argId) {\n    const nameField = new Blockly.FieldTextInput(name, this.validator_);\n    nameField.onFinishEditing_ = this.finishEditing_.bind(nameField);\n    nameField.varIdsToDelete_ = [];\n    nameField.preEditVarModel_ = null;\n\n    this.appendDummyInput(argId)\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(createMinusField(argId))\n        .appendField(Blockly.Msg['PROCEDURE_VARIABLE']) // Untranslated!\n        .appendField(nameField, argId); // The name of the field is the arg id.\n  },\n\n  /**\n   * Validates text entered into the argument name field.\n   * @param {string} newName The new text entered into the field.\n   * @returns {?string} The field's new value.\n   * @this {Blockly.FieldTextInput}\n   */\n  validator_: function(newName) {\n    const sourceBlock = this.getSourceBlock();\n    const workspace = sourceBlock.workspace;\n    const argData = sourceBlock.argData_;\n    const argDatum = sourceBlock.argData_.find(\n        (element) => element.argId == this.name);\n    const currId = argDatum.model.getId();\n\n    // Replace all whitespace with normal spaces, then trim.\n    newName = newName.replace(/[\\s\\xa0]+/g, ' ').trim();\n    const caselessName = newName.toLowerCase();\n\n    /**\n     * Returns true if the given argDatum is associated with this field, or has\n     * a different caseless name than the argDatum associated with this field.\n     * @param {{model: Blockly.VariableModel, argId:string}} argDatum The\n     *     argDatum we want to make sure does not conflict with the argDatum\n     *     associated with this field.\n     * @returns {boolean} True if the given datum does not conflict with the\n     *     datum associated with this field.\n     * @this {Blockly.FieldTextInput}\n     */\n    const hasDifName = (argDatum) => {\n      // The field name (aka id) is always equal to the arg id.\n      return argDatum.argId == this.name ||\n          caselessName != argDatum.model.name.toLowerCase();\n    };\n    /**\n     * Returns true if the variable associated with this field is only used\n     * by this block, or callers of this procedure.\n     * @returns {boolean} True if the variable associated with this field is\n     *     only used by this block, or callers of this procedure.\n     */\n    const varOnlyUsedHere = () => {\n      return workspace.getVariableUsesById(currId).every((block) => {\n        return block.id == sourceBlock.id ||\n            (block.getProcedureCall &&\n                block.getProcedureCall() == sourceBlock.getProcedureDef()[0]);\n      });\n    };\n\n    if (!newName || !argData.every(hasDifName)) {\n      if (this.preEditVarModel_) {\n        argDatum.model = this.preEditVarModel_;\n        this.preEditVarModel_ = null;\n      }\n      Blockly.Procedures.mutateCallers(sourceBlock);\n      return null;\n    }\n\n    if (!this.varIdsToDelete_.length) {\n      this.preEditVarModel_ = argDatum.model;\n      if (varOnlyUsedHere()) {\n        this.varIdsToDelete_.push(currId);\n      }\n    }\n\n    // Create new vars instead of renaming the old ones, so users can't\n    // accidentally rename/coalesce vars.\n    let model = workspace.getVariable(newName, '');\n    if (!model) {\n      model = workspace.createVariable(newName, '');\n      this.varIdsToDelete_.push(model.getId());\n    } else if (model.name != newName) {\n      // Blockly is case-insensitive so we have to update the var instead of\n      // creating a new one.\n      workspace.renameVariableById(model.getId(), newName);\n    }\n    if (model.getId() != currId) {\n      argDatum.model = model;\n    }\n    Blockly.Procedures.mutateCallers(sourceBlock);\n    return newName;\n  },\n\n  /**\n   * Removes any unused vars that were created as a result of editing.\n   * @param {string} _finalName The final value of the field.\n   * @this {Blockly.FieldTextInput}\n   */\n  finishEditing_: function(_finalName) {\n    const source = this.getSourceBlock();\n    const argDatum = source.argData_.find(\n        (element) => element.argId == this.name);\n\n    const currentVarId = argDatum.model.getId();\n    this.varIdsToDelete_.forEach((id) => {\n      if (id != currentVarId) {\n        source.workspace.deleteVariableById(id);\n      }\n    });\n    this.varIdsToDelete_.length = 0;\n    this.preEditVarModel_ = null;\n  },\n};\n\n/**\n * Initializes some private variables for procedure blocks.\n * @this {Blockly.Block}\n */\nconst procedureDefHelper = function() {\n  /**\n   * An array of objects containing data about the args belonging to the\n   * procedure definition.\n   * @type {!Array<{\n   *          model:Blockly.VariableModel,\n   *          argId: string\n   *       }>}\n   * @private\n   */\n  this.argData_ = [];\n  /**\n   * Does this block have a 'STACK' input for statements?\n   * @type {boolean}\n   * @private\n   */\n  this.hasStatements_ = true;\n\n  this.getInput('TOP').insertFieldAt(0, createPlusField(), 'PLUS');\n};\n\nBlockly.Extensions.registerMutator('procedure_def_mutator',\n    procedureDefMutator, procedureDefHelper);\n\n/**\n * Sets the validator for the procedure's name field.\n * @this {Blockly.Block}\n */\nconst procedureRename = function() {\n  this.getField('NAME').setValidator(Blockly.Procedures.rename);\n};\n\nBlockly.Extensions.register('procedure_rename', procedureRename);\n\n/**\n * Defines functions for dealing with variables and renaming variables.\n * @this {Blockly.Block}\n */\nconst procedureVars = function() {\n  // This is a hack to get around the don't-override-builtins check.\n  const mixin = {\n    /**\n     * Return all variables referenced by this block.\n     * @returns {!Array.<string>} List of variable names.\n     * @this {Blockly.Block}\n     */\n    getVars: function() {\n      return this.argData_.map((elem) => elem.model.name);\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     * @returns {!Array.<!Blockly.VariableModel>} List of variable models.\n     * @this {Blockly.Block}\n     */\n    getVarModels: function() {\n      return this.argData_.map((elem) => elem.model);\n    },\n\n    /**\n     * Notification that a variable was renamed to the same name as an existing\n     * variable. These variables are coalescing into a single variable with the\n     * ID of the variable that was already using the name.\n     * @param {string} oldId The ID of the variable that was renamed.\n     * @param {string} newId The ID of the variable that was already using\n     *     the name.\n     */\n    renameVarById: function(oldId, newId) {\n      const argData = this.argData_.find(\n          (element) => element.model.getId() == oldId);\n      if (!argData) {\n        return; // Not on this block.\n      }\n\n      const newVar = this.workspace.getVariableById(newId);\n      const newName = newVar.name;\n      this.addVarInput_(newName, newId);\n      this.moveInputBefore(newId, oldId);\n      this.removeInput(oldId);\n      argData.model = newVar;\n      Blockly.Procedures.mutateCallers(this);\n    },\n\n    /**\n     * Notification that a variable is renaming but keeping the same ID.  If the\n     * variable is in use on this block, rerender to show the new name.\n     * @param {!Blockly.VariableModel} variable The variable being renamed.\n     * @package\n     * @override\n     * @this {Blockly.Block}\n     */\n    updateVarName: function(variable) {\n      const id = variable.getId();\n      const argData = this.argData_.find(\n          (element) => element.model.getId() == id);\n      if (!argData) {\n        return; // Not on this block.\n      }\n      this.setFieldValue(variable.name, argData.argId);\n      argData.model = variable;\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n\nBlockly.Extensions.register('procedure_vars', procedureVars);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the text_join block to use a +/- mutator UI.\n */\n\nimport Blockly from 'blockly/core';\nimport {createPlusField} from './field_plus';\nimport {createMinusField} from './field_minus';\n\nconst textJoinMutator = {\n  /**\n   * Number of text inputs on this block.\n   * @type {number}\n   */\n  itemCount_: 0,\n\n  /**\n   * Creates XML to represent number of inputs.\n   * @returns {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function() {\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('items', this.itemCount_);\n    return container;\n  },\n\n  /**\n   * Parses XML to restore the inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    const targetCount = parseInt(xmlElement.getAttribute('items'), 10);\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @returns {{itemCount: number}} The state of this block, ie the item count.\n   */\n  saveExtraState: function() {\n    return {\n      'itemCount': this.itemCount_,\n    };\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, ie the item count.\n   */\n  loadExtraState: function(state) {\n    this.updateShape_(state['itemCount']);\n  },\n\n  /**\n   * Adds inputs to the block until the block reaches the target input count.\n   * @param {number} targetCount The number of inputs the block should have.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function(targetCount) {\n    while (this.itemCount_ < targetCount) {\n      this.addPart_();\n    }\n    while (this.itemCount_ > targetCount) {\n      this.removePart_();\n    }\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the plus image. Adds an input to the block and updates the\n   * state of the minus.\n   * @this {Blockly.Block}\n   */\n  plus: function() {\n    this.addPart_();\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the minus image. Removes the input at the end of the block and\n   * updates the state of the minus.\n   * @this {Blockly.Block}\n   */\n  minus: function() {\n    if (this.itemCount_ == 0) {\n      return;\n    }\n    this.removePart_();\n    this.updateMinus_();\n  },\n\n  /**\n   * Adds an input to the end of the block. If the block currently has no\n   * inputs it updates the top 'EMPTY' input to receive a block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  addPart_: function() {\n    if (this.itemCount_ == 0) {\n      if (this.getInput('EMPTY')) {\n        this.removeInput('EMPTY');\n      }\n      this.topInput_ = this.appendValueInput('ADD' + this.itemCount_)\n          .appendField(createPlusField(), 'PLUS')\n          .appendField(Blockly.Msg['TEXT_JOIN_TITLE_CREATEWITH']);\n    } else {\n      this.appendValueInput('ADD' + this.itemCount_);\n    }\n    // Because item inputs are 0-index we decrement first, increment last.\n    this.itemCount_++;\n  },\n\n  /**\n   * Removes an input from the end of the block. If we are removing the last\n   * input this updates the block to have an 'EMPTY' top input.\n   * @this {Blockly.Block}\n   * @private\n   */\n  removePart_: function() {\n    this.itemCount_--;\n    this.removeInput('ADD' + this.itemCount_);\n    if (this.itemCount_ == 0) {\n      this.topInput_ = this.appendDummyInput('EMPTY')\n          .appendField(createPlusField(), 'PLUS')\n          .appendField(this.newQuote_(true))\n          .appendField(this.newQuote_(false));\n    }\n  },\n\n  /**\n   * Makes it so the minus is visible iff there is an input available to remove.\n   * @private\n   */\n  updateMinus_: function() {\n    const minusField = this.getField('MINUS');\n    if (!minusField && this.itemCount_ > 0) {\n      this.topInput_.insertFieldAt(1, createMinusField(), 'MINUS');\n    } else if (minusField && this.itemCount_ < 1) {\n      this.topInput_.removeField('MINUS');\n    }\n  },\n};\n\n/**\n * Adds the quotes mixin to the block. Also updates the shape so that if no\n * mutator is provided the block has two inputs.\n * @this {Blockly.Block}\n */\nconst textJoinHelper = function() {\n  Blockly.Extensions.apply('text_quotes', this, false);\n  this.updateShape_(2);\n};\n\nif (Blockly.Extensions.isRegistered('text_join_mutator')) {\n  Blockly.Extensions.unregister('text_join_mutator');\n}\nBlockly.Extensions.registerMutator('text_join_mutator',\n    textJoinMutator, textJoinHelper);\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","getExtraBlockState","block","saveExtraState","state","JSON","stringify","mutationToDom","Blockly","createMinusField","args","minus","minusImage","onClick_","args_","minusField","getSourceBlock","isInFlyout","oldExtraState","newExtraState","createPlusField","plus","plusImage","plusField","controlsIfMutator","elseIfCount_","hasElse_","container","setAttribute","domToMutation","xmlElement","targetCount","parseInt","getAttribute","getInput","appendStatementInput","appendField","updateShape_","create","loadExtraState","addElseIf_","removeElseIf_","index","appendValueInput","setCheck","moveInputBefore","elseIfIndex","inputs","inputList","connection","isConnected","disconnect","bumpNeighbours","input","name","targetConnection","connect","removeInput","insertFieldAt","listCreateMutator","itemCount_","addPart_","removePart_","updateMinus_","topInput_","appendDummyInput","getField","removeField","getProcedureDef","argNames","argData_","map","elem","model","getFieldValue","callType_","procedureContextMenu","customContextMenu","options","text","xml","appendChild","callback","push","enabled","isCollapsed","getVarModels","procedureDefMutator","isForCaller","forEach","element","argument","argModel","getId","argId","hasStatements_","names","varIds","argIds","childNodes","childNode","nodeName","toLowerCase","length","arg","param","Error","removeArg_","addArg_","varId","withField","variable","workspace","addVarInput_","filter","nameField","validator_","onFinishEditing_","finishEditing_","bind","varIdsToDelete_","preEditVarModel_","setAlign","newName","sourceBlock","argData","argDatum","find","currId","caselessName","replace","trim","every","getVariableUsesById","id","getProcedureCall","getVariable","renameVariableById","createVariable","_finalName","source","currentVarId","deleteVariableById","setValidator","mixin","getVars","renameVarById","oldId","newId","newVar","getVariableById","updateVarName","setFieldValue","textJoinMutator","newQuote_"],"sourceRoot":""}